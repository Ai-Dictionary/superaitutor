class ExamInterface {
    constructor(questionSet={}) {
        this.sidenav = 0;
        this.termination = 0;
        this.temp = '';
        this.currentPaper = null;
        this.currentCategory = 1;

        this.root = document.getElementById('root');
        this.questions1 = [];
        this.questions2 = [];
        this.questions3 = [];
        this.questionSet = questionSet;
        this.user();
        ExamInterface.instance = this;
    }

    user() {
        // window.addEventListener("blur", () => {
        //     if (new URL(window.location['href']).hostname !== '') {
        //         showAlert(`You should change window ${this.termination + 1} time, please stop move otherwise your exam should cancel.`);
        //         this.termination++;
        //     }
        // });

        // window.addEventListener("focus", () => {
        //     if (new URL(window.location['href']).hostname !== '') {
        //         if (this.termination > 3 && this.termination < 5) {
        //             alert("Your exam is cancelled for unwanted movement!");
        //         }
        //     }
        // });

        document.addEventListener('click', (e) => {
            if (e.target.closest('.sidenav-toggler')) {
                this.toggleSidenav();
            }
        });

        this.setExamData();
        if (this.deviceCheck() !== 2) {
            this.toggleSidenav();
        }
    }

    toggleSidenav() {
        console.log("flage");
        if (this.sidenav === 0) {
            if (this.deviceCheck() !== 2) {
                document.querySelector(".right-component").style.width = "0%";
                document.querySelector(".sidenav-toggler").style.position = "absolute";
                document.querySelector(".sidenav-toggler").style.top = "58%";
                document.querySelector(".sidenav-toggler").style.left = "90%";
                setTimeout(() => {
                    document.querySelector(".right-component").style.display = "none";
                }, 1000);
            } else {
                document.querySelector(".right-component").style.width = "0%";
                document.querySelector(".left-component").style.width = "100%";
                document.querySelector(".sidenav-toggler").style.position = "absolute";
                document.querySelector(".sidenav-toggler").style.top = "58%";
                document.querySelector(".sidenav-toggler").style.left = "98%";
            }
            document.querySelector(".sidenav-toggler").innerHTML = '<i class="fa fa-arrow-left"></i>';
            this.sidenav++;
        } else {
            if (this.deviceCheck() !== 2) {
                document.querySelector(".right-component").style.display = "block";
                document.querySelector(".right-component").style.width = "70%";
                document.querySelector(".sidenav-toggler").style.position = "absolute";
                document.querySelector(".sidenav-toggler").style.top = "58%";
                document.querySelector(".sidenav-toggler").style.left = "22%";
            } else {
                document.querySelector(".right-component").style.width = "20%";
                document.querySelector(".left-component").style.width = "80%";
                document.querySelector(".sidenav-toggler").style.position = "absolute";
                document.querySelector(".sidenav-toggler").style.top = "58%";
                document.querySelector(".sidenav-toggler").style.left = "78%";
            }
            document.querySelector(".sidenav-toggler").innerHTML = '<i class="fa fa-arrow-right"></i>';
            this.sidenav--;
        }
    }

    static closeAlert() {
        document.querySelector(".alert").style.top = "-8%";
        setTimeout(() => {
            document.querySelector(".alert").style.display = "none";
        }, 1000);
    }

    setPaper() {
        let raw_paper = document.querySelector('.raw_info').innerText;
        let paper;
        if (Object.keys(this.questionSet).length === 0) {
            console.log("ExamInterface object is maked with out questionSet, why?");
        }else{
            paper = this.questionSet;
        }
        for (const key of Object.keys(paper.question)) {
            if (key.startsWith("set")) {
                paper.question[key] = paper.question[key].map(item => {
                    const [text, choices, answer] = item;
                    return new Question(text, choices, answer);
                });
            }
        }
        this.currentPaper = paper;
        raw_paper = '';
    }

    deviceCheck() {
        const details = navigator.userAgent;
        let regexp = /android|iphone|kindle|ipad/i;
        let regexc = /windows|linux|macintosh/i;
        let isMobileDevice = regexp.test(details);
        let isComputer = regexc.test(details);
        if (isMobileDevice) {
            return 0;
        } else {
            if (isComputer) {
                return 2;
            }
            return 1;
        }
    }

    setExamData() {
        this.setPaper();
        setTimeout(() => {
            const engine = new ExamEngine(this.currentPaper, this.currentCategory, this.root);
            engine.reorderSection();
            engine.populate(1);
        }, 1000);
    }

    static get_currentPaper() {
        return ExamInterface.instance?.currentPaper || [];
    }
}

function showAlert(message) {
    document.querySelector(".alert").style.display = "block";
    document.getElementById("alert-message").innerHTML = message;
    setTimeout(() => {
        document.querySelector(".alert").style.top = "8%";
    }, 100);
}

class ExamManger {
    constructor() {
        this.key = window.key;
        this.get_paper();
    }
    encoder(plain_txt, key){
        const vocabulary = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@!*+#%$&^,|?/";
        let cipher = "";
        key = key.repeat(Math.ceil(plain_txt.length / key.length));

        for(let i = 0; i < plain_txt.length; i++){
            let plain_txtIndex = vocabulary.indexOf(plain_txt[i]);
            let keyIndex = vocabulary.indexOf(key[i]);
            if(plain_txtIndex !== -1 && keyIndex !== -1){
                let newIndex = (plain_txtIndex + keyIndex) % vocabulary.length;
                cipher += vocabulary[newIndex];
            } else {
                cipher += plain_txt[i];
            }
        }
        return cipher;
    }
    h_task(num, status) {
        const holder = document.querySelector('.h_task_holder');
        const tasks = holder.querySelectorAll('.h_task');

        const task = tasks[num - 1];
        if (!task) return;

        task.style.display = 'flex';

        const mark = task.querySelector('.mark');
        mark.innerHTML = status ? '<i class="fa fa-check"></i>' : '<i class="fa fa-times"></i>';
    }
    c_task(text) {
        document.querySelector('.c_task_holder .c_task').innerText = text;
    }
    async get_paper() {
        let raw_paper = document.querySelector('.raw_info').innerText;
        let paper = JSON.parse(raw_paper, null, 2);
        window.key = 0;
        if (Object.keys(paper?.question).length === 0) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log("times up, api not send any question under time limit");
            }, 10000);
            try {
                const response = await fetch("/api/mindvault", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({queryKey: this.encoder(String(paper.init.id+'-'+paper.name+'-'+paper.topic+'-'+paper.fullmarks).replaceAll(' ', '%20'), this.key)}),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
                if(data != undefined || Object.keys(data).length != 0){
                    paper.question = data.paper.question;
                    paper.section = data.paper.section;
                    this.exam_start(paper);
                }
            } catch (error) {
                if (error.name !== "AbortError") {
                    console.error("Fetch error:", error);
                }else{
                    console.log(error);
                }
            }
        }else{
            this.exam_start();
        }
    }
    exam_start(paper={}) {
        document.body.removeChild(document.getElementById('loader'));
        document.getElementById('mainPage').style.display = 'block';
        new ExamInterface(paper);
    }
}

new ExamManger();